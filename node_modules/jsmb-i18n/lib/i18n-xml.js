var fs = require('fs');
var path = require('path');
//var XM = require('xml-mapping');
var XM = require('xml2js');
var mkdir = require('jsmb-util').mkdir;

var CHARSET = "utf-8";
var XMLTMP = '<?xml version="1.0" encoding="utf-8"?>\n<resources xmlns:android="http://schemas.android.com/apk/res/android">\n{items}</resources>';
var XMLITEM = '    <string name="{key}">{value}</string>\n';

// 用于提取自定义标记的待翻译字符串，只匹配以下四种格式
// _("...")		适用于html等
// _('...')		适用于html等
// '_("...")'	适用于html、js、php等
// "_('...')"	适用于html、js、php等
var XREG = /('__\("[^\r\n\t("\)]*"\)')|("__\('[^\r\n\t('\))]*'\)")|(__\("[^\r\n\t^("\))]*"\))|(__\('[^\r\n\t^('\))]*'\))/g;

// 替换提取的字符串
var GREG = function (str) {
    return str.replace(/^__\("|"\)$|^__\('|'\)$|^"__\('|'\)"$|^'__\("|"\)'$/g, "");
}

// 需要翻译的文件类型
var FILETYPE = /\.(php|html|htm|htpl|tpl|js)$/;

module.exports = new I18n();

function I18n() {
}


/**
 * 加载xml
 * @param src   源文件
 * @returns {key1: val1, key2: val2, ...}
 */
function loadXML(src) {
    var rs = {};
    var error = false;
    //var list = XM.load(fs.readFileSync(src, CHARSET));
    //if(list.resources && list.resources.string){
    //    if(list.resources.string instanceof Array){
    //        list.resources.string.forEach(function (item) {
    //            rs[item.name] = item['$t'];
    //        });
    //    }else{
    //        rs[list.resources.string.name] = list.resources.string['$t'];
    //    }
    //}

    XM.parseString(fs.readFileSync(src, CHARSET), function (err, result) {
        if(err){
            console.log(err);
            error = true;
            return;
        }
        if (result.resources && result.resources.string) {
            result.resources.string.forEach(function (item) {
                rs[item['$'].name] = item['_'];
            });
        }
    });

    if(error){
        return false;
    }else{
        return rs;
    }
}


I18n.prototype.xgettext = function (src, dist, exist) {
    if (!src) {
        console.log("Source file(or directory) is required!");
        return;
    }
    if (!dist) {
        if (fs.statSync(src).isDirectory()) {
            dist = src + '/i18n_xml';
            mkdir(dist);
        } else {
            dist = path.join(path.dirname(src), path.basename(src).replace(/\.[^\n\.]*$/, ''));
        }
    }
    if (dist && !/\.[^\n]$/.test(dist)) {
        mkdir(dist);
    }

    saveXML(src, dist, exist);

    function saveXML(src, dist, exist) {
        // 若存在已提取好的文件
        var existedList = exist && fs.existsSync(exist) ? loadXML(exist) : {} && mkdir(path.dirname(exist));
        if(existedList === false){
            console.log('Exited i18n xml had some error formate item, please check file ' + exist);
            return;
        }

        // 若src提取为空
        existedList === undefined ? existedList = {} : null;

        var extractedList = extract(src);

        // 确保存在
        if (!exist || !fs.existsSync(exist)) {
            fs.writeFileSync(path.join(dist, "all.xml"), XMLTMP.replace("{items}", ""), CHARSET);
        }

        // 查找记录最后合并时间的文件是否存在
        var lastUpdateFile = path.join(dist, "update.time");
        var lastUpdate;
        if (fs.existsSync(lastUpdateFile)) {
            lastUpdate = fs.readFileSync(lastUpdateFile, CHARSET);
        } else {
            lastUpdate = 0;
        }

        // 以某个时间线合并存在的xml文件，合并之后删除
        var xmlList = fs.readdirSync(dist);
        xmlList.forEach(function (file) {
            if (/\.xml/.test(file) && file !== path.basename(exist)) {
                var filename = path.join(dist, file);
                if (fs.statSync(filename).mtime.getTime() > lastUpdate) {
                    //console.log(filename, fs.statSync(filename).mtime.getTime(), lastUpdate)
                    var list = loadXML(filename);
                    for (var itm in list) {
                        existedList[itm] = list[itm];
                    }
                }
            }
        });

        // 将已存在翻译的覆盖提取的
        for (var itm in existedList) {
            extractedList[itm] = existedList[itm];
        }

        // 生成xml文件
        var output = "";
        for (itm in extractedList) {
            output += XMLITEM.replace("{key}", itm).replace("{value}", extractedList[itm]);
        }
        // 保存为xml
        fs.writeFileSync(exist, XMLTMP.replace("{items}", output), CHARSET);

        // 更新最后更改时间的记录文件
        fs.writeFileSync(lastUpdateFile, new Date().getTime(), CHARSET);

    }


    /**
     * 提取标记的待翻译字符串
     * @param  {String}    file  源文件或文件夹
     * @param  {Boolean}   merge  同gettext
     */
    function extract(file, dist) {
        var rs = null;

        if (fs.existsSync(file)) {
            if (fs.statSync(file).isFile()) {
                rs = extractSingle(file);
            } else if (fs.statSync(file).isDirectory()) {
                rs = extractMerge(file);
            } else {
                console.log(file + "type isn't avaliabled!");
            }
        } else {
            console.log(file + "isn't existed!");
        }

        return rs;


        /**
         * 单文件提取msgid
         * @attention  当匹配出相同时，则需要做记录
         * @param  {String}    file  源文件
         * @param  {Object}    output  匹配的条目对象
         */
        function extractSingle(file, output) {
            // 根据换行符分割数组
            var content = fs.readFileSync(file, CHARSET).split(/\n/g);

            // 输出数组
            output = output || {};

            // 临时
            var tmp, m, n, key;

            // 逐行匹配，将匹配到待翻译的字符串入队
            for (var i = 0, l = content.length; i < l; i++) {
                tmp = content[i].match(XREG);
                if (tmp) {
                    for (m = 0, n = tmp.length; m < n; m++) {
                        key = GREG(tmp[m]);

                        // 排除重复的key
                        if (!(key in output)) {
                            output[key] = key;
                        }
                    }
                }
            }

            return output;
        }


        /**
         * 多文件文件提取msgid并合并
         * @param  {String}    dir  源文件夹
         * @param  {Object}    output  匹配的条目对象
         */
        function extractMerge(dir, output) {
            if (dir.indexOf(dist) > -1) {
                return;
            }
            var list = fs.readdirSync(dir);
            var file;
            output = output || {};
            list.forEach(function (name, idx) {
                file = dir + '/' + name;
                if (fs.statSync(file).isDirectory()) {
                    extractMerge(file, output);
                } else {
                    extractSingle(file, output);
                }
            });
            return output;
        }

    }
}

I18n.prototype.gettext = function (lang, i18n, src, dist, replacestr) {
    if (fs.existsSync(i18n)) {
        if (!dist) {
            if (fs.statSync(src).isDirectory()) {
                dist = src + '_dist';
            } else {
                dist = path.dirname(src) + '_dist/' + path.basename(src);
            }
        }

        // 确保输出的目标文件夹存在
        fs.existsSync(dist) ? null : mkdir(dist);

        gettextXML();
    } else {
        console.log(i18n + " isn't existed!");
    }


    /**
     *
     */
    function gettextXML() {
        // @读取文件修改记录的缓存文件，保存在i18n参数的文件夹下
        var target = path.dirname(i18n);
        var recode = path.join(target, ('I18N_' + lang).toUpperCase() + '.json');

        if (!fs.existsSync(recode)) {
            fs.writeFileSync(recode, '{}', 'utf-8');
        }
        var cache = require(recode);

        // 获取翻译文件
        var matches = loadXML(i18n);

        // 根据文件和文件夹处理
        if (fs.statSync(src).isDirectory()) {
            traverseFilesInner.call(this, src);
        } else {
            translate.call(this, src, dist);
        }

        // @回写文件修改记录的缓存文件
        fs.writeFileSync(recode, JSON.stringify(cache), 'utf-8');


        /**
         * 遍历文件夹进行翻译
         * @param  {String}    dir  源文件夹
         */
        function traverseFilesInner(dir) {
            var list = fs.readdirSync(dir);
            var file, fileDist;
            var time;
            list.forEach(function (name, idx) {
                file = dir + '/' + name;
                fileDist = file.replace(src, dist);

                // 需要过滤某些类型的文件
                if (fs.statSync(file).isDirectory()) {
                    // 需要创建相关的文件夹，确保写文件的时候不会出错
                    fs.existsSync(fileDist) ? null : fs.mkdirSync(fileDist);
                    traverseFilesInner(file);
                } else {
                    time = fs.statSync(file).mtime.getTime();
                    //if (!(file in cache && cache[file] === time)) {
                        cache[file] = time;
                        if (FILETYPE.test(path.extname(file))) {
                            translate(file, fileDist, replacestr);
                        } else {
                            // 直接复制不需要翻译的文件
                            fs.writeFileSync(fileDist, fs.readFileSync(file));
                        }
                    //}
                }
            })
        }


        /**
         * 翻译原文件，输出翻译后的内容
         * @param  {String}    file  源文件路径
         * @param  {String}    dist  翻译后的目前文件路径
         */
        function translate(file, dist, rpstr) {
            var content = fs.readFileSync(file, CHARSET);
            var tmp;
            for (var itm in matches) {
                content = content.replace(new RegExp(('__("' + itm + '")' + "|__('" + itm + "')").replace(/[`~!@#$%^&*()+<>?:{},.\/;\[\]]/g, '\\$&'), 'g'), rpstr ? rpstr : matches[itm] !== "" ? matches[itm] : itm);
            }

            // 输出文件
            fs.writeFileSync(dist, content, CHARSET);
        }
    }
}